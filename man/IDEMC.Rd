% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/idemc.R
\name{IDEMC}
\alias{IDEMC}
\title{IDEMC Point Generation}
\usage{
IDEMC(xsamp, ems, targets, s, sn, p, imp = 3, verbose = F, ...)
}
\arguments{
\item{xsamp}{The initial sample of points, as a data.frame}

\item{ems}{The emulators with which to evaluate implausibility}

\item{targets}{The corresponding output targets}

\item{s}{The number of points to generate in the burn-in phase}

\item{sn}{The final number of points to generate}

\item{p}{The proportion of points to keep in each new ladder rung}

\item{imp}{The value of implausibility that is ultimately desired}

\item{verbose}{Should logging messages be outputted? Default: F}

\item{...}{Any additional parameters to pass to \code{IDEMC_step}}
}
\value{
A list of data.frames, corresponding to the points generated.
}
\description{
Performs Implausibility-Driven Evolutionary Monte Carlo.
}
\details{
Given a set of initial points (preferably space-filling across the space in question),
the implausibility ladder is set up via a burn-in phase. Once the ladder of implausibilities
has been determined, these are used to generate the full set of points.

This is a very computationally expensive procedure for generating points, and should only be
used when it is strongly suspected that the target region is extremely small or has an
interesting disconnected structure. For more mundane point generation, a more suitable
approach is the functionality in \code{\link{generate_new_runs}}.

The burn-in phase starts with a rung defined over the full space (i.e. the implausibility
for this rung is simply the maximum implausibility over the space). The implausibility of
the next rung is chosen to be such that 30% of the previous points are below this threshold.
A full complement of points are generated at this new level, and the process is repeated
using these new points to find the next rung of the ladder. This iterates until the desired
final implausibility, \code{imp} has been reached as a ladder rung.

Once the burn in has been performed, a full set of points are generated at each rung of the
ladder (where it is assumed that the burn-in generated fewer points than required, so that
\code{sn}<\code{s}).
}
\examples{
\dontrun{
ranges <- list(aSI = c(0.1, 0.8), aIR = c(0, 0.5), aSR = c(0, 0.05))
out_vars <- c('nS', 'nI', 'nR')
o_ems <- emulator_from_data(GillespieSIR, out_vars, ranges)
t_ems <- purrr::map(seq_along(o_ems), ~o_ems[[.]]$adjust(GillespieSIR, out_vars[[.]]))
z <- list(
 nS = list(val = 281, sigma = 10.43),
 nI = list(val = 30, sigma = 11.16),
 nR = list(val = 689, sigma = 14.32)
)
start_pts <- data.frame(
  aSI = runif(500, ranges$aSI[1], ranges$aSI[2]),
  aIR = runif(500, ranges$aIR[1], ranges$aIR[2]),
  aSR = runif(500, ranges$aSR[1], ranges$aSR[2])
)
result <- IDEMC(start_pts, t_ems, z, 50, 100, 0.3, imp = 2)
}

}
\references{
Vernon, I. & Williamson, D. (2013) Efficient uniform designs for multi-wave computer experiments. arXiv:1309.3520
}
\seealso{
\code{\link{generate_new_runs}} for other point generation methods.
}
